//place this content in your buildSrc/build.gradle file
//Then apply your plugin to its own build in build.gradle
import org.codehaus.groovy.control.CompilerConfiguration

apply plugin: 'groovy'

repositories {
    jcenter()
    mavenCentral()
    maven {
        url "https://oss.sonatype.org/content/repositories/snapshots/"
    }
}

// IntelliJ doesn't let you set the source path for a module outside of its directory. 
// This logic basically only performs this configuration when not being resolved in IntelliJ
if (!project.plugins.collect { it.class.name}.any { it.endsWith('JetGradlePlugin')}) {

    //Set the source directories for buildSrc to contain the source from the main project
    sourceSets {
        main {
            java.srcDirs = ['src/main/java', '../src/main/java']
            groovy.srcDirs = ['src/main/groovy', '../src/main/groovy']
            resources.srcDirs = ['src/main/resources', '../src/main/resources']
        }
    }
}


// Prepare to have your mind blown
// This section evaluates the `build.gradle` from the root diretory and
// then grabs the dependencies block from it and evaluates it on this project.
// So in effect, we are building the main project with itself.
// BOOM

ScriptHolder holder = new ScriptHolder()
CompilerConfiguration cc = new CompilerConfiguration()
cc.setScriptBaseClass(DelegatingScript.class.name)
GroovyShell sh = new GroovyShell(Project.class.classLoader, new Binding(), cc)

//The build file for the main project
File projectBuildFile = file('../build.gradle')

//Use this parse command because Groovy wants to use the file name as the classname 
//which fails if your Gradle build file has been renamed to contain an invalid character (i.e. '-')
DelegatingScript script = (DelegatingScript)sh.parse(projectBuildFile.text, 'GradlePlugins')
script.setDelegate(holder)

//Resolve the project main Gradle file against our ScriptHolder
script.run()

//Class for holding the evaluation of a Gradle script
//You may need to add some extra methods here depending on what you have all placed in build.gradle
class ScriptHolder {
    Closure dependencies
    Closure repositories
    Closure util

    void dependencies(Closure c) {
        this.dependencies = c
    }

    void repositories(Closure c) {
        this.repositories = c
    }

    void util(Closure c) {
        this.util = c
    }

    void apply(Map map) {

    }
}

class UtilHolder {
    def javaVersion
}

//Grab the dependencies closure and resolve it against 
//the buildSrc project dependencies
//This effectively applies the same dependenices from build.gradle into buildSrc/build.gradle
//This is required so that when buildSrc is compiled it has the dependencies to compile the source code
def closure = holder.dependencies.clone()
closure.delegate = project.dependencies
closure()
closure = holder.repositories.clone()
closure.delegate = project.repositories
closure()
closure = holder.util.clone()
project.ext.util = new UtilHolder()
closure.delegate = project.util
closure()